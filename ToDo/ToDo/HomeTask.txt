 
Задание на вторник

Написать API для реализации todo листа

Поля сущности todo: Id (int), Label (string), IsDone (bool), CreatedDate (DateTime), UpdatedDate (DateTime)

API должно содержать следующие методы:

GET /todos - получить все записи. Опционально принимать GET параметры limit (int), offset (int). Limit - максимально количество возвращаемых записей, offset - количество пропускаемых записей 

GET /todos/{id} - получить запись по Id

GET /todos/{id}/IsDone - получить флаг (вернуть json вида {id:1, IsDone: true})

POST /todos - создать новую запись, вернуть созданную запись с кодом ответа 201 и ссылкой на созданный ресурс. Сохранить время создание записи в UTC формате (DateTime.UtcNow)

PUT /todos/{id} - обновить запись, вернуть обновленную запись. Обновить поле UpdatedDate текущим UTC временем. Не обновлять поля CreatedDate и UpdatedDate данными от клиентской стороны 

PATCH /todos/{id}/IsDone - обновить поле IsDone у конкретной записи, запрос отправляет json вида {isDone:true}, ответ в виде {id:1, IsDone: true}

DELETE /todos/{id} - удалить запись 

Если при выполнении любого запроса, включающего в себя Id сущности, обнаруживается, что такой сущности нет, вернуть ответ 404. Хранить список можно в статическом поле типа List<Todo>. За основу можно взять шаблон web api с контроллерами 

============================
Задание на четверг:

Разделить приложение на несколько проектов:

Todos.Api - web api, содержит api для работы с todo
Todos.Service - библиотека, содержит сервисы для работы с Todo
Todos.Repositories -  библиотека, содержит репозитории для работы с Todo
Todos.Domain - библиотека, содержит сущность Todo

Users.Api -  web api, содержит api для работы с User
Users.Service - библиотека, содержит сервисы для работы с User

Common.Repositories -  библиотека, содержит репозитории для работы с User
Common.Domain -  библиотека, содержит сущность User

Реализовать соответствующие сервисы и репозитории. Использовать интерфейсы для связывания контроллеров, сервисов и репозиториев. 

Добавить в Todo поле OwnerId

При добавлении новой Todo или редактировании поля OwnerId проверять, что существует пользователь с таким Id. Если такого нет, вызвать исключение 

В метод GET /todos добавить фильтры по OwnerId (полное совпадение), LabelFreeText - частичное совпадение с игнорированием локали и регистра

==============================================
Дополнение к текущему заданию

Добавить DTO классы для методов добавления и редактирования сущностей в сервисах 
Добавить AutoMapper для копирования полей из DTO в Domain модель
Поменять конкретные реализации репозиторием на дженерики (файл репозитория и интерфейс прикрепляю)
Добавить заголовок x-Total-Count для GET /todos и  GET /users
Вынести инжектирование зависимостей бизнес логики в метод расширения, находящийся в проекте бизнес логики

==============================================
Добавить Fluent валидатор и Serilog

1. Установить Fluent в проекты бизнес логики. Необходимые библиотеки: FluentValidation и FluentValidation.DependencyInjectionExtensions
2. Добавить валидаторы для моделей Create и Update
3. Добавить автоматическое инжектирование в bl проекте: services.AddValidatorsFromAssemblies(new[] { Assembly.GetExecutingAssembly() }, includeInternalTypes: true);
4. Добавить фильтр для валидации запросов к контроллеру. Можно использовать библиотеку SharpGrip.FluentValidation.AutoValidation.Mvc 
(код для добавления сервиса    builder.Services.AddFluentValidationAutoValidation();)

5. Добавить легирование в api проект. Библиотека Serilog.AspNetCore
6. Обернуть код в program.cs в блок try, catch, finally. Залогировать исключения. Написать в лог сообщение о запуске приложения
7. Залагировать операции POST, PUT, PUTCH, DELET на уровне BL в коде сервисов. Сохранить в лог dto в json формате

================================================
Задача на вторник-четверг

Так как видео нет (видимо оно долго обрабатывалось, а 8 марта у it академии выходной), прикрепляю файлы с примерами кода из лекции

1. Добавить middleware для перехвата исключений, вызываемых проектом бизнес логики. 
Для этого нужно добавить класс middleware и включить его в цепочку вызовов. 
Класс должен обрабатывать минимум два вида исключений: ресурс не найден (код 404) и некорректный запрос (код 400).
Исключения можно добавить в Common.Domain или Common.BL, middleware в Common.Api (он не является частью BL)



Добавить подключение к базе данных при помощи Entity Framework. Для этого

1. Устанавливаем сервер базы данных на свой компьютер (ссылка на SQL сервер, но можно использовать любую реакционную базу данных - https://www.microsoft.com/en-us/sql-server/sql-server-downloads) 
Для подключения и управления базой данных можно использовать либо родную для конкретного сервера программу (для SQL Server это SQL Server Management Studio https://learn.microsoft.com/en-us/sql/ssms/download-sql-server-management-studio-ssms?view=sql-server-ver16)
В качестве альтернативы можно использовать Azure Data Studio, она умеет работать со всему существующими СУБД https://azure.microsoft.com/en-us/products/data-studio

2. В проект Common.Repositories устанавливаем пакет Microsoft.EntityFrameworkCore.
Устанавливаем пакет провайдеры для выбранной СУБД в проект где настраивается инжектирование контекста базы данных (для SQL Server это Microsoft.EntityFrameworkCore.SqlServer).
Можно инжектировать его через метод расширение из проекта Common.Repositories

3. Создать контекст базы данных. Контекст должен хранить в себе поля DbSet<T> для каждого типа каждой сущности, что будет храниться в бд.
Настроить взаимосвязь между сущностями и ограничения полей в бд можно через ModelBuilder в перегрузки метода OnModelCreating (пример прикрепляю)

4. Нужно создать новую реализацию обобщенного репозитория, уже используя DbContext, инжектировать новую реализацию вместо старой. 
Добавить пару асинхронных методов в интерфейс и, соотвественно, реализацию. 
Существующие методы интерфейса не менять для наглядности как можно для одного интерфейса использовать разные реализации

5. В файл конфигурации appsettings.json обоих проектов добавить строку подключения к серверу базы данных на вашем компьютере. 
Использовать ее для создания контекста при помощи IConfiguration 
6. Создать и выполнить миграцию для базы данных. В проект запуска с настроенной конфигурации использующем инжектирование добавить пакет Microsoft.EntityFrameworkCore.Design. 
Открыть в консоли папку с проектом запуска и либо выполнить команду 
dotnet ef migrations add Initial --project “путь к файлу Common.Repositories.csproj ”, 
либо, при использовании VS, можно использовать команду PowerShell: Add-Migration InitialCreate. 
По аналогии запустить миграции. Подробности можно почитать по ссылке https://learn.microsoft.com/en-us/ef/core/managing-schemas/migrations/?tabs=vs .
При использовании команд консоли может понадобиться библиотека Microsoft.EntityFrameworkCore.Tools (при использовании дизайнера не нужна, но может пригодится если пакеты консоли не были установлены глобально в ОС)
7. При необходимости внести изменения в реализацию сервисов (например id должен генерироваться автоматический базой данных). 
Добавить пару новых или изменить старые методы сервисов на асинхронные с передачей токена отмены операции
